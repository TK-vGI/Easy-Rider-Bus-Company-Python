import re
import json

# path_to_html = "./Unlost in time/task.html"

pattern_stop_name = re.compile(r'^([A-Z][a-z]+(?: [A-Z][a-z]+)*) (Road|Avenue|Boulevard|Street)$')
pattern_stop_type = re.compile(r'[SOF]?$')
pattern_a_time = re.compile(r'^(?:[01]\d|2[0-3]):[0-5]\d$')

correct_data_types = {
    "bus_id": {"type": int, "format": False, "required": True},
    "stop_id": {"type": int, "format": False, "required": True},
    "stop_name": {"type": str, "format": pattern_stop_name, "required": True},
    "next_stop": {"type": int, "format": False, "required": True},
    "stop_type": {"type": str, "format": pattern_stop_type, "required": False},
    "a_time": {"type": str, "format": pattern_a_time, "required": True}
}

correct_bus_lines = {
    128: {"stops": 4, "start_stop": "Prospekt Avenue", "final_stop": "Sesame Street",
          "stop_names": ["Prospekt Avenue", "Bourbon Street", "Sunset Boulevard", "Sesame Street"],
          "color": "red"},
    256: {"stops": 4, "start_stop": "Pilotow Street", "final_stop": "Sesame Street",
          "stop_names": ["Pilotow Street", "Elm Street", "Fifth Avenue", "Sesame Street"],
          "color": "green"},
    512: {"stops": 2, "start_stop": "Bourbon Street", "final_stop": "Sunset Boulevard",
          "stop_names": ["Bourbon Street", "Sunset Boulevard"],
          "color": "blue"},
}


def output(err, bus_lines, stops_start_final, transfers, interrupted=False, bad_line=None) -> None:
    total_err = sum(err.values())
    print(f"Type and field validation: {total_err} errors")
    for key in correct_data_types:
        print(f"{key}: {err[key]}")
    print()
    print("Line names and number of stops:")
    for bus, stops in bus_lines.items():
        print(f"bus_id: {bus} stops: {stops}")
    if interrupted:
        print(f"There is no start or end stop for the line: {bad_line}")
    else:
        # stops_start_final = {"bus_id":{"S":["stop_name",...], "F":["stop_name",...]}}
        starts, finishes = get_unique_stops_by_type(stops_start_final)
        print(f"\nStart stops: {len(starts)} {starts}")
        print(f"Transfer stops: {len(transfers)} {transfers}")
        print(f"Finish stops: {len(finishes)} {finishes}")


def get_unique_stops_by_type(stops_start_final):
    start_stops = set()
    finish_stops = set()
    # stops_start_final = {"bus_id":{"S":["stop_name",...], "F":["stop_name",...]}}
    for stops in stops_start_final.values():
        start_stops.update(stops["S"])
        finish_stops.update(stops["F"])
    return sorted(start_stops), sorted(finish_stops)


def is_required_field_valid(value, required):
    return not (required and value == "")


def is_type_valid(value, expected_type):
    return isinstance(value, expected_type)


def is_format_valid(value, format_pattern):
    return format_pattern is False or re.match(format_pattern, str(value))


def aggregate_errors(data: dict) -> dict[str, int]:
    error_list = {key: 0 for key in correct_data_types}

    for line in data:
        for field, specs in correct_data_types.items():
            value = line.get(field)
            required = specs["required"]
            expected_type = specs["type"]
            format_pattern = specs["format"]

            # Check for required fields
            if not is_required_field_valid(value, required):
                error_list[field] += 1
                continue

            # Check for correct type
            if value is not None and not is_type_valid(value, expected_type):
                error_list[field] += 1
                continue

            # Check format if pattern exist
            if value is not None and not is_format_valid(value, format_pattern):
                error_list[field] += 1

    return error_list


def count_bus_stops(data: list[dict]) -> dict[int, int]:
    stop_counts = {}

    for line in data:
        bus_id = line.get("bus_id")

        # Only count valid bus_id entries
        if isinstance(bus_id, int):
            stop_counts[bus_id] = stop_counts.get(bus_id, 0) + 1

    return stop_counts


def get_stop_types_by_line(data: list[dict]) -> dict[int, dict[str, list[str]]]:
    stops_start_final = {}

    for line in data:
        bus_id = line["bus_id"]
        stop_name = line["stop_name"]
        stop_type = line.get("stop_type", "")

        if isinstance(bus_id, int) and isinstance(stop_name, str):
            stops_start_final.setdefault(bus_id, {"S": [], "F": []}) # {"bus_id":{"S":[], "F":[]}}
            if stop_type in ("S", "F"):
                stops_start_final[bus_id][stop_type].append(stop_name) # {"bus_id":{"S":["stop_name",...], "F":["stop_name",...]}}

    return stops_start_final


def valid_bus_line(stop_type_map: dict[int, dict[str, list[str]]]) -> tuple[bool, int | None]:
    # Check if bus-line has start & final stops, interrupt if any does not meet this condition
    # Change possibility: check and output all bad bus-lines in list
    for bus_id, stops in stop_type_map.items():
        if len(stops["S"]) != 1 or len(stops["F"]) != 1:
            print(f"There is no start or end stop for the line: {bus_id}")
            return False, bus_id  # interrupt, do not continue checking other bus-lines
    return True, None


def find_transfer_stops(data):
    transfer_stops = {}
    for line in data:
        stop_name = line["stop_name"]
        bus_id = line["bus_id"]
        transfer_stops.setdefault(stop_name, set()).add(bus_id)  # {"stop_name":(bus_line#1, bus_line#2,...)}

    # Select stop_names with at least 2 bus-lines, return sorted list
    transfers = [stop_name for stop_name, bus_lines in transfer_stops.items() if len(bus_lines) > 1]

    return sorted(transfers)


def load_data():
    return json.loads(input())


def main():
    # # Open and read the JSON file
    # with open('test_file_4.json', 'r', encoding='utf-8') as file:
    #     data = json.load(file)

    data = load_data()

    # Check errors in input file
    result_errors = aggregate_errors(data)

    # Count number of stops for respective bus-line
    bus_lines = count_bus_stops(data)

    # Check and assign to list Start & Final stops for respective bus-line
    stops_start_and_final = get_stop_types_by_line(data)

    # Check if bus-line has Start & Final stops, interrupt if any does not meet this condition
    valid, bad_bus = valid_bus_line(stops_start_and_final)

    # Check and sort Start / Transfer / Final stops for respective bus-line
    stops_transfer = find_transfer_stops(data)

    # Output results
    output(result_errors, bus_lines, stops_start_and_final, stops_transfer, interrupted=not valid, bad_line=bad_bus)


if __name__ == "__main__":
    main()